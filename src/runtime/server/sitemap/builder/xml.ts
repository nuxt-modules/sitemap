import type { ModuleRuntimeConfig, NitroUrlResolvers } from '../../../types'

function resolveKey(k: string) {
  switch (k) {
    case 'images':
      return 'image'
    case 'videos':
      return 'video'
    // news & others?
    case 'news':
      return 'news'
    default:
      return k
  }
}
function handleObject(key: string, obj: Record<string, any>) {
  // internal keys
  return [
    `        <${key}:${key}>`,
    ...Object.entries(obj).map(([sk, sv]) => {
      if (key === 'video' && Array.isArray(sv)) {
        return sv.map((v) => {
          if (typeof v === 'string') {
            return [
              `            `,
              `<${key}:${sk}>`,
              escapeValueForXml(v),
              `</${key}:${sk}>`,
            ].join('')
          }
          const attributes = Object.entries(v)
            .filter(([ssk]) => ssk !== sk)
            .map(([ssk, ssv]) => `${ssk}="${escapeValueForXml(ssv)}"`).join(' ')
          return [
            `            <${key}:${sk} ${attributes}>`,
            // value is the same sk
            v[sk],
            `</${key}:${sk}>`,
          ].join('')
        }).join('\n')
      }
      if (typeof sv === 'object') {
        if (key === 'video') {
          // we need to attributify the object
          const attributes = Object.entries(sv)
            .filter(([ssk]) => ssk !== sk)
            .map(([ssk, ssv]) => `${ssk}="${escapeValueForXml(ssv)}"`).join(' ')
          return [
            `            <${key}:${sk} ${attributes}>`,
            // value is the same sk
            sv[sk],
            `</${key}:${sk}>`,
          ].join('')
        }
        return [
          `            <${key}:${sk}>`,
          ...Object.entries(sv).map(([ssk, ssv]) => `                <${key}:${ssk}>${escapeValueForXml(ssv)}</${key}:${ssk}>`),
          `            </${key}:${sk}>`,
        ].join('\n')
      }
      return `            <${key}:${sk}>${escapeValueForXml(sv)}</${key}:${sk}>`
    }),
    `        </${key}:${key}>`,
  ].join('\n')
}

function handleArray(key: string, arr: Record<string, any>[]) {
  if (arr.length === 0)
    return false
  key = resolveKey(key)
  if (key === 'alternatives') {
    return arr.map(obj => [
      `        <xhtml:link rel="alternate" ${Object.entries(obj).map(([sk, sv]) => `${sk}="${escapeValueForXml(sv)}"`).join(' ')} />`,
    ].join('\n')).join('\n')
  }
  return arr.map(obj => handleObject(key, obj)).join('\n')
}
export function handleEntry(k: string, e: Record<string, any> | (string | Record<string, any>)[]) {
  // @ts-expect-error type juggling
  return Array.isArray(e[k]) ? handleArray(k, e[k]) : typeof e[k] === 'object' ? handleObject(k, e[k]) : `        <${k}>${escapeValueForXml(e[k])}</${k}>`
}

export function wrapSitemapXml(input: string[], resolvers: NitroUrlResolvers, options: Pick<ModuleRuntimeConfig, 'version' | 'xsl' | 'credits' | 'minify'>) {
  const xsl = options.xsl ? resolvers.relativeBaseUrlResolver(options.xsl) : false
  const credits = options.credits

  input.unshift(`<?xml version="1.0" encoding="UTF-8"?>${xsl ? `<?xml-stylesheet type="text/xsl" href="${xsl}"?>` : ''}`)
  if (credits)
    input.push(`<!-- XML Sitemap generated by @nuxtjs/sitemap v${options.version} at ${new Date().toISOString()} -->`)
  if (options.minify)
    return input.join('').replace(/(?<!<[^>]*)\s(?![^<]*>)/g, '')
  return input.join('\n')
}

// Pre-compiled regex for better performance
const XML_CHAR_REGEX = /[&<>"']/g
const XML_CHAR_MAP: Record<string, string> = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&apos;',
}

export function escapeValueForXml(value: boolean | string | number) {
  if (value === true || value === false)
    return value ? 'yes' : 'no'

  const str = String(value)
  // Fast path for strings without special characters
  if (!XML_CHAR_REGEX.test(str)) {
    return str
  }

  // Reset regex state for reuse
  XML_CHAR_REGEX.lastIndex = 0
  return str.replace(XML_CHAR_REGEX, char => XML_CHAR_MAP[char])
}
